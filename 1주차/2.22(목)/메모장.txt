main 메소드 내에 모든 기능을 작성하지 말고, 나누어서 작성해라.
문제를 쪼갤 수 없을 때까지 쪼개기 (Divide & Conquer)

추상화 : 불필요한 것을 제외하고, 필요한 것만 명확히 제공하는 기법
피카소의 그림, 칸단스키의 도시
- 데이터를 추상화하는 방법
- 프로시저를 추상화하는 방법
=> 함수를 생각해보자
함수는 기능에 집중을 한다.
VS
프로시저 : 함수와는 상관없이 일정한 순서에 따라 실행해야 하는 블록 (절차에 집중)
함수가 어떻게 동작하는지는 알 필요없고, 인자만 전달하고 기능만 사용해.
함수는 값을 반환하는게 목적. 프로시저는 절차적으로 statement를 실행하는게 목적이므로 반환값이 없어도 됨.

java 는 함수와 프로시저를 동일하게 사용.

method 란? : 
객체는 상태와 행위(동작). 2가지로 구분할 수 잇다.
객체가 동작을 할 수 있는 것을 선언한 것을 method 라고 한다.

폰노이만 아키텍처에서 모든 동작을 하기 위해서는 데이터가 메모리 내에 있어야 한다.
ex. Class 를 객체로 선언
바인딩 : 디스크 -> 메모리로 데이터 로딩
Dynamic Binding : 필요할 때만 로딩
Static Binding : 항상 메모리에 로딩되어 있음

5장. 메소드와 파라미터
대부분의 응용 프로그램을 설계할 때, 응용 프로그램을 기능 단위로 나눕니다. 코드를 작은 부분으로 나누면 설계가 용이하고, 코드를 이해하기 쉬우며, 단위로 디버깅 할 수 있기 때문에 코드를 작은 부분으로 나누는 것은 응용 프로그램을 디자인하는 핵심 원칙입니다.

Javad에서는 클래스들 내에서 명명된 코드 블록을 단위로 응용 프로그램을 구성합니다. 이것을 메소드라고 하며, 메소드는 작업을 수행하거나 값을 계산하는, 클래스의 구성원입니다.

- 메소드 선언
block 이란 : 같은 동작을 실행하기 위해 묶여있는 statement의 묶음
메소드 : 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것
함수, 서브루틴, 프로시저, 서브 프로그램과 비슷한 개념

main 이 static 이 아니면 메모리에 적재가 안되어 있는 상태라 실행이 안될 것임. 
표준 출력을 위해 System.out 이라는 객체를 사용.


-- 메소드 생성
JVM 내에 스태틱 공간은 따로 있음. 정적 바인딩 시 여기에 적재됨. C언어의 함수와 똑같이 동작.
=> Hello.java
이름 + 파라미터 + 바디가 있어야 함.

-- 메소드 호출
다른 클래스에서 메소드 호출
중첩 호출도 가능하다.
본인이 본인을 호출도 가능하다 = 재귀호출

-- return statement
return문을 만나면 메소드는 실행을 멈추고 즉시 호출자 코드로 돌아감
메소드가 void 가 아닌 다른 타입으로 정의된 경우 반환 메커니즘을 사용하여 호출자에게 값을 반환합니다.

-- 지역변수
메소드 안에 할당된 변수
클래스 변수 = 클래스 안에, 메소드 밖에 선언된 변수

-- 값 return
void 는 반환을 하지 않지만 프로시저 역할을 한다. return을 사용하는 경우에는 특정 조건에 따라 메소드를 종료시켜야 할 때 사용한다.

- 파라미터
-- 파라미터 선언과 호출
재귀호출 max(max(i, j), k)

000000-- 파라미터 전달 매커니즘
Pass by Value
Pass by Reference
 + 실습 : passtest.java
자바는 참조넘기기 지원하지 않음. 무조건 pass by value 임. 
사용하려면 int[] array 등의 배열 사용해서 넘길것

일반 int i 는 formal Parameter 라고 한다.
(1+2) 가 파라미터 일 시에는 actual Parameter 라고 한다.

int i = 5; int j = i;	와
int [] array = {1,2}; int [] array2 = array		는
완벽하게 다르게 동작한다.


-- 가변 길이 목록 파라미터 사용
int max(int... values) { }
이 때 values 는 int 타입의 배열로 인식을 한다.
 + 실습 : changepara.java

-- 재귀 메소드 사용
조건에 맞을 때까지 함수를 호출해 새로운 지역 스택이 계속 생성된다.
ex). 피보나치 수열 (인구 감소 예측)

- 메소드 오버로딩
같은 이름의 메소드여도, 파라미터 개수에 맞는 메소드로 실행된다. 
만약 파라미터 개수가 같은데, 서로 타입이 다르다면 파라미터 타입이 같은 메소드로 실행된다.
=> 이를 메소드 오버로딩이라고 한다. 이는 다형성 중 하나의 방법이다.

-- 메소드 시그너처
컴파일러는 시그너처를 사용하여 클래스의 메소드를 구분합니다. 각 클래스에서 각 메소드의 시그너처는 유일해야 합니다.
메소드 시그너처는 메소드의 이름, 파라미터의 타입, 파라미터의 개수로 구성됩니다.
메소드 시그너처는 return 타입을 포함하지 않습니다. 아래 두 메소드는 같은 시그너처로 판단되어 컴파일시에 오류를 출력합니다.

??? ) 배열의 주솟값은 8 진수로 출력하면 실제 주소값일까? 주소가 8bits 로 구성되어 있나?


-- 오버로드 된 메소드 사용
객체지향 프로그래밍 언어의 4가지 원칙 : Open&Close principle
디버깅과 유지 보수가 어려움

- Lab 5_1

과제). 가변길이목록 재귀함수로 구현하기
 + pythontutor.com

- Lab 5_2
마지막 accumulator 실습. 자바에서는 함수를 파라미터로 넘길 수 없다.

정적 바인딩 : 컴파일 타이밍에 로딩 다 됨.
얼리 바인딩(메소드 오버로딩) & 레이트 바인딩(메소드 오버라이딩)


과제). 익일 11:30까지
자바로 틱택토 구현
내가 입력시 컴퓨터가 자동(랜덤)으로 입력
가로, 세로, 대각선 연결시 우승.
마지막에 누가 승리 했는지 출력

힌트). SOLID 법칙 적용해라. 메소드 하나가 한 가지 일만 하도록 만들기
화면 찍는 메소드 하나
문자열 자르는 메소드 하나
배열 값 찍는 메소드 하나
승리 판단 메소드 하나
-> 함수와 프로시저를 기반으로 메소드를 디바이드&콘커